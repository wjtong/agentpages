
# 基于LLM的生产级Web应用生成器 - 设计框架 (V9 - NocoDB)

## 1. 愿景与目标

(与V8版本相同)

---

## 2. 系统定位：真正的“动态应用平台”

(与V8版本相同)

---

## 3. 主数据管理 (通过 NocoDB)

这是一个核心架构变更。为了实现最大程度的解耦和复用，我们决定将**主数据管理**的功能完全外包给开源工具**NocoDB**。

- **职责划分:**
    - **NocoDB:** 负责所有主数据（如产品、仓库、客户）的创建、管理和维护。业务人员可以通过NocoDB的电子表格化界面轻松地管理这些核心数据。NocoDB会自动为这些数据表提供REST API。
    - **本系统:** **不再存储和管理任何主数据**。它通过API成为NocoDB中主数据的**消费者**。其核心职责是利用这些主数据作为上下文，来构建动态的、事务性的业务流程应用（如采购申请、报销等）。

---

## 4. 运行时动态应用架构 (集成NocoDB)

**核心思想:** 系统的业务上下文（主数据）由外部NocoDB提供，系统自身则专注于动态应用的生成和渲染。

```mermaid
graph TD
    subgraph "数据管理 (外部)"
        U[业务人员] <--> NocoDB[NocoDB 实例];
        NocoDB -- 提供 --> API[REST API for Master Data];
    end

    subgraph "本系统"
        subgraph "Admin (App Creator)"
            A[Admin] -- "我要创建..." --> D[LLM智能引擎];
        end

        subgraph "设计与注册"
            D -- "1. 获取'产品'表结构" --> API;
            D -- "2. 生成定义" --> E_UI["UI定义 (JSON)"];
            D -- 生成 --> E_LOGIC["前端逻辑 (JS)"];
            D -- 生成 --> E_SCHEMA["后端校验规则 (JSON)"];
            E_UI & E_LOGIC & E_SCHEMA -- 存入 --> DB[(系统数据库)];
        end

        subgraph "End User (App User)"
            Q[End User] --> P{用户门户};
            P -- 点击应用 --> R[动态应用渲染器];
            R -- 读取 --> DB;
            R -- "获取'产品'列表" --> T[通用后端API];
            T -- "代理请求" --> API;
            R -- 执行逻辑 --> S[安全沙箱 (Web Worker)];
            R -- 提交数据 --> T;
            T -- 写入数据 --> DB;
        end
    end
```

### 4.1. 关键组件
- **NocoDB集成:** 系统后端现在包含一个“NocoDB服务”，负责根据配置（NocoDB地址、API令牌）与NocoDB的REST API通信，以获取主数据的**元数据（表结构）**和**实例数据（记录列表）**。

---

## 5. 核心工作流程 (集成NocoDB)

**前提：** 业务人员已在NocoDB中创建了名为`Products`的表，并添加了若干产品记录。

### 5.1. 阶段一：Admin 创建应用
1.  **发起:** Admin在“创建新业务”页面选择“产品”作为上下文。
2.  **获取上下文:** **(核心变更)** 本系统后端首先调用NocoDB的元数据API，获取`Products`表的详细结构（字段名、类型等）。
3.  **LLM解析:** 系统将用户的自然语言请求和从NocoDB获取的`Products`表结构一起提供给LLM。LLM据此推理出数据模型和UI工作流。
4.  **生成与注册:** (同V8) 系统生成应用的UI/逻辑/校验规则定义，并存入**自己的数据库**中。

### 5.2. 阶段二：End User 使用应用
1.  **访问与动态渲染:** (同V8)
2.  **交互 (获取主数据):** **(核心变更)** 在渲染采购申请的第一步（选择产品）时，前端渲染器会调用本系统的后端API（如`GET /api/master-data/products`）。该API会代理请求，从NocoDB的`GET /.../Products`接口获取产品列表，然后返回给前端。
3.  **提交与存储:** (同V8) 最终的采购申请单数据，依然存储在本系统的`business_records`表的`jsonb`字段中。

---

## 6. 动态运行时实现方案

### 6.1. 核心技术栈
(同V8)

### 6.2. 数据库核心表结构
- **本系统数据库 (PostgreSQL):**
    - `business_records`: (同V8) 存储用户提交的业务数据。
    - `app_definitions`: (同V8) 存储AI生成的应用定义。
    - **注意:** `products`等所有主数据表**已从本系统数据库中移除**。

### 6.3. 动态代码执行策略
(同V8)

### 6.4. NocoDB 集成策略
- **配置:** 系统后端需增加环境变量：`NOCODB_BASE_URL` 和 `NOCODB_AUTH_TOKEN`。
- **元数据发现:** 在Admin创建应用时，后端服务会调用NocoDB的元数据API（如 `/api/v1/db/meta/tables`）来获取表结构，作为LLM的上下文。
- **数据代理:** 后端应提供一个通用的数据代理接口，如`GET /api/proxy/master-data/:tableName`。前端通过此接口向后端请求主数据，后端再从NocoDB获取并返回。这样做的好处是：
    - 统一管理API凭证，无需暴露给前端。
    - 可以在后端进行数据缓存、转换或聚合。

---

## 7. 动态运行时架构的核心挑战

(同V8)

---

## 8. 初始实现切片 (MVP Slice)

**目标:** 验证与外部NocoDB API的集成，并打通核心渲染流程。

### 8.1. MVP范围
1.  **主数据:** **(核心变更)** 假设一个NocoDB实例正在运行，并已创建`Products`表。在开发初期，如果NocoDB未就绪，可在后端创建一个**模拟服务 (Mock Service)**，它模拟NocoDB的API，返回一个硬编码的产品列表JSON数组。
2.  **应用定义:** (同V8) 手动在`app_definitions`表中插入一条“采购申请单”的记录。
3.  **UI渲染器:** (同V8) 支持`Page`, `Form`, `Input`, `Button`，并新增支持`Select`组件用于选择产品。
4.  **后端API:**
    - `POST /api/records/purchase_requisition`: (同V8) 接收数据并打印到控制台。
    - `GET /api/proxy/master-data/Products`: **(新增)** 实现此接口，它调用（或模拟调用）NocoDB API来获取产品列表。

### 8.2. 关键实现规格
(与V8类似，但`ui_definition`需增加一个`Select`组件来展示从NocoDB获取的产品列表)

### 8.3. 预期结果
- **启动:** (同V8)
- **渲染:** **(核心变更)** 点击“采购申请单”应用后，页面上应出现一个**下拉选择框**，其中包含了从（模拟的）NocoDB API获取的产品列表。
- **交互与提交:** 选择一个产品后，填写表单并提交，后端控制台打印出提交的数据。
